<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Ops: WebGL FPS</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD Elements */
        .hud-row { padding: 20px; display: flex; justify-content: space-between; align-items: flex-end; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            transform: translate(-50%, -50%); border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 50%;
            transition: transform 0.1s;
        }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: cyan; transform: translate(-50%, -50%); }
        
        .stat-box { background: rgba(0, 20, 40, 0.7); color: #0ff; padding: 15px; border: 1px solid #0ff; border-radius: 4px; text-shadow: 0 0 5px #0ff; }
        .stat-label { font-size: 12px; opacity: 0.7; display: block; margin-bottom: 5px; }
        .stat-value { font-size: 32px; font-weight: bold; }
        
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0); transition: box-shadow 0.1s; pointer-events: none; }
        
        #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; pointer-events: auto; z-index: 10; }
        #instructions { text-align: center; color: white; cursor: pointer; }
        h1 { font-size: 40px; text-transform: uppercase; letter-spacing: 5px; border-bottom: 2px solid cyan; display: inline-block; }
        p { font-size: 18px; margin-top: 10px; }
        
        #ammo-bar { width: 100%; height: 5px; background: #333; margin-top: 5px; }
        #ammo-fill { height: 100%; background: #0ff; width: 100%; transition: width 0.2s; }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="damage-overlay"></div>
    <div id="ui-layer">
        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">SCORE</span>
                <span class="stat-value" id="score">0</span>
            </div>
        </div>
        
        <div id="crosshair"></div>

        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">HEALTH</span>
                <span class="stat-value" id="health">100</span>
            </div>
            <div class="stat-box" style="text-align: right;">
                <span class="stat-label">AMMUNITION</span>
                <span class="stat-value" id="ammo">30</span>
                <div id="ammo-bar"><div id="ammo-fill"></div></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1>Neon Protocol</h1>
            <p>Click to Initialize Neural Link</p>
            <p style="font-size: 14px; opacity: 0.7;">(W,A,S,D to Move | SPACE to Jump | CLICK to Fire | R to Reload)</p>
        </div>
    </div>

    <!-- Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. PROCEDURAL TEXTURE GENERATION SYSTEM ---
        // Generates realistic gritty textures on the fly using Canvas API to avoid external assets.
        const textureLoader = new THREE.TextureLoader();
        
        function createProceduralTexture(type, colorBase) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Fill background
            ctx.fillStyle = colorBase;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add Noise
            for (let i = 0; i < 50000; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }

            // Specific Details
            if (type === 'concrete') {
                for(let i=0; i<50; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random()*512, Math.random()*512, Math.random()*20, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(0,0,0,0.05)`;
                    ctx.fill();
                }
            } else if (type === 'metal') {
                // Scratches
                ctx.strokeStyle = 'rgba(200,200,200,0.2)';
                ctx.lineWidth = 1;
                for(let i=0; i<100; i++) {
                    ctx.beginPath();
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.random()*50 - 25, y + Math.random()*50 - 25);
                    ctx.stroke();
                }
                // Rust
                for(let i=0; i<20; i++) {
                    ctx.fillStyle = `rgba(139, 69, 19, ${Math.random()*0.3})`;
                    ctx.fillRect(Math.random()*512, Math.random()*512, Math.random()*60, Math.random()*60);
                }
            } else if (type === 'grid') {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                for(let i=0; i<=512; i+=64) {
                    ctx.moveTo(i, 0); ctx.lineTo(i, 512);
                    ctx.moveTo(0, i); ctx.lineTo(512, i);
                }
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const texConcrete = createProceduralTexture('concrete', '#444');
        const texMetal = createProceduralTexture('metal', '#2a2a2a');
        const texFloor = createProceduralTexture('grid', '#111');
        texFloor.repeat.set(10, 10);

        // --- 2. GAME SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 200, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 3. LEVEL GENERATION ---
        // Floor
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ map: texFloor, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls (Randomly placed to create cover)
        const wallGeo = new THREE.BoxGeometry(4, 8, 4);
        const wallMat = new THREE.MeshStandardMaterial({ map: texConcrete, roughness: 0.9 });

        for (let i = 0; i < 40; i++) {
            const wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.x = (Math.random() - 0.5) * 100;
            wall.position.z = (Math.random() - 0.5) * 100;
            wall.position.y = 4;
            wall.scale.set(1 + Math.random() * 2, 1 + Math.random(), 1 + Math.random() * 2);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        // --- 4. PLAYER CONTROLLER & WEAPON ---
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isSprinting = false;

        // Weapon Model (Procedural)
        const weaponGroup = new THREE.Group();
        const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 0.6);
        const gunMat = new THREE.MeshStandardMaterial({ map: texMetal, color: 0x333333, metalness: 0.8, roughness: 0.2 });
        const gunMesh = new THREE.Mesh(gunGeo, gunMat);
        gunMesh.position.set(0.2, -0.2, -0.5);
        gunMesh.castShadow = true;
        
        // Scope/Sight
        const sightGeo = new THREE.BoxGeometry(0.05, 0.05, 0.1);
        const sightMesh = new THREE.Mesh(sightGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff }));
        sightMesh.position.set(0, 0.15, 0.2);
        gunMesh.add(sightMesh);

        // Muzzle Flash Light
        const muzzleLight = new THREE.PointLight(0x00ffff, 0, 5);
        muzzleLight.position.set(0, 0, -0.6);
        gunMesh.add(muzzleLight);

        weaponGroup.add(gunMesh);
        camera.add(weaponGroup);
        scene.add(camera); // Add camera to scene

        // Weapon State
        const weapon = {
            damage: 25,
            fireRate: 100, // ms
            lastFire: 0,
            maxAmmo: 30,
            currentAmmo: 30,
            reloading: false,
            sway: { x: 0, y: 0 },
            recoil: 0
        };

        // Inputs
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) velocity.y += 15; canJump = false; break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyR': reload(); break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Mouse Listeners for Shooting
        let isFiring = false;
        document.addEventListener('mousedown', () => { if(controls.isLocked) isFiring = true; });
        document.addEventListener('mouseup', () => { isFiring = false; });

        // --- 5. ENEMY AI SYSTEM ---
        const enemies = [];
        const enemyGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
        const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff0044, metalness: 0.5, roughness: 0.5 });
        
        function spawnEnemy() {
            if(enemies.length > 8) return; // Limit enemies
            const enemy = new THREE.Mesh(enemyGeo, enemyMat.clone());
            
            // Random position away from player
            const angle = Math.random() * Math.PI * 2;
            const dist = 20 + Math.random() * 30;
            enemy.position.set(
                camera.position.x + Math.cos(angle) * dist,
                2,
                camera.position.z + Math.sin(angle) * dist
            );
            
            enemy.userData = { health: 60, lastAttack: 0 };
            enemy.castShadow = true;
            scene.add(enemy);
            enemies.push(enemy);
        }

        // --- 6. PARTICLES & EFFECTS ---
        const particles = [];
        function createExplosion(pos, color) {
            const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const particleMat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<15; i++) {
                const mesh = new THREE.Mesh(particleGeo, particleMat);
                mesh.position.copy(pos);
                // Random velocity
                mesh.userData = {
                    vel: new THREE.Vector3(
                        (Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)
                    ).normalize().multiplyScalar(0.2 + Math.random()*0.3),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        // --- 7. GAME LOGIC ---
        let prevTime = performance.now();
        const player = { health: 100, score: 0 };

        function updateHUD() {
            document.getElementById('health').innerText = Math.max(0, Math.floor(player.health));
            document.getElementById('ammo').innerText = weapon.currentAmmo;
            document.getElementById('score').innerText = player.score;
            document.getElementById('ammo-fill').style.width = (weapon.currentAmmo / weapon.maxAmmo * 100) + '%';
            
            // Crosshair bloom on recoil
            const spread = 20 + weapon.recoil * 100;
            const ch = document.getElementById('crosshair');
            ch.style.width = spread + 'px';
            ch.style.height = spread + 'px';
        }

        function reload() {
            if(weapon.reloading || weapon.currentAmmo === weapon.maxAmmo) return;
            weapon.reloading = true;
            // Simple animation trick
            gunMesh.rotation.x = -Math.PI/4; 
            setTimeout(() => {
                weapon.currentAmmo = weapon.maxAmmo;
                weapon.reloading = false;
                gunMesh.rotation.x = 0;
                updateHUD();
            }, 1000);
        }

        function shoot() {
            const now = performance.now();
            if (now - weapon.lastFire < weapon.fireRate || weapon.reloading || weapon.currentAmmo <= 0) return;

            weapon.lastFire = now;
            weapon.currentAmmo--;
            weapon.recoil += 0.1;
            
            // Muzzle Flash
            muzzleLight.intensity = 5;
            setTimeout(() => muzzleLight.intensity = 0, 50);

            // Raycast
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children);

            let hitSomething = false;

            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;
                if (object === floor) continue; // Don't shoot floor immediately
                
                // Hit enemy
                if (enemies.includes(object)) {
                    object.userData.health -= weapon.damage;
                    createExplosion(intersects[i].point, 0xff0044); // Blood
                    object.material.emissive.setHex(0xffffff);
                    setTimeout(() => object.material.emissive.setHex(0x000000), 50);
                    
                    if (object.userData.health <= 0) {
                        // Kill
                        createExplosion(object.position, 0xffaa00);
                        scene.remove(object);
                        enemies.splice(enemies.indexOf(object), 1);
                        player.score += 100;
                    }
                    hitSomething = true;
                    break;
                } else if(object !== gunMesh && object !== sightMesh) {
                    // Hit wall
                    createExplosion(intersects[i].point, 0xcccccc); // Dust
                    hitSomething = true;
                    break;
                }
            }
            
            // Camera Shake/Kick
            camera.rotation.x += 0.002;
            gunMesh.position.z += 0.1; // Kickback model

            updateHUD();
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // --- PHYSICS ---
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 20.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = isSprinting ? 120.0 : 60.0;
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta); // Move Up/Down

                // Floor Collision
                if (controls.getObject().position.y < 2) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2;
                    canJump = true;
                }

                // --- WEAPON DYNAMICS ---
                // Return to rest
                gunMesh.position.z = THREE.MathUtils.lerp(gunMesh.position.z, -0.5, delta * 10);
                weapon.recoil = Math.max(0, weapon.recoil - delta * 2);

                // Sway (Movement Bob)
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    const bobFreq = isSprinting ? 15 : 10;
                    const bobAmp = isSprinting ? 0.02 : 0.01;
                    gunMesh.position.y = -0.2 + Math.sin(time * 0.01 * bobFreq) * bobAmp;
                    gunMesh.position.x = 0.2 + Math.cos(time * 0.01 * bobFreq) * bobAmp;
                } else {
                    gunMesh.position.y = THREE.MathUtils.lerp(gunMesh.position.y, -0.2, delta * 5);
                    gunMesh.position.x = THREE.MathUtils.lerp(gunMesh.position.x, 0.2, delta * 5);
                }

                // Fire Logic
                if(isFiring) shoot();

                // --- AI LOGIC ---
                // Spawn logic
                if (Math.random() < 0.01) spawnEnemy();

                enemies.forEach(enemy => {
                    // Look at player
                    enemy.lookAt(camera.position.x, enemy.position.y, camera.position.z);
                    
                    // Move towards player
                    const dist = enemy.position.distanceTo(camera.position);
                    if(dist > 2) {
                        const dir = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                        enemy.position.add(dir.multiplyScalar(delta * 4)); // Enemy Speed
                    }

                    // Attack Player
                    if(dist < 3 && time - enemy.userData.lastAttack > 1000) {
                        player.health -= 10;
                        enemy.userData.lastAttack = time;
                        updateHUD();
                        
                        // Red flash
                        const overlay = document.getElementById('damage-overlay');
                        overlay.style.boxShadow = "inset 0 0 100px rgba(255,0,0,0.5)";
                        setTimeout(() => overlay.style.boxShadow = "none", 200);

                        if(player.health <= 0) {
                            controls.unlock();
                            alert("GAME OVER - Score: " + player.score);
                            location.reload();
                        }
                    }
                });

                // --- PARTICLES ---
                for(let i=particles.length-1; i>=0; i--) {
                    const p = particles[i];
                    p.userData.life -= delta * 2;
                    p.position.add(p.userData.vel);
                    p.scale.multiplyScalar(0.95);
                    if(p.userData.life <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // --- START GAME HANDLER ---
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        instructions.addEventListener('click', function () {
            controls.lock();
        });

        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });

        controls.addEventListener('unlock', function () {
            blocker.style.display = 'flex';
            instructions.style.display = '';
        });

        // Initialize HUD
        updateHUD();
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>