<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Ops: Mountain Ascent</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Press Start 2P', monospace; user-select: none; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 5; }
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0); transition: box-shadow 0.1s; pointer-events: none; z-index: 4; }
        
        /* HUD */
        .hud-row { padding: 25px; display: flex; justify-content: space-between; align-items: flex-end; }
        
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; 
            transform: translate(-50%, -50%); border: 2px solid rgba(0, 255, 255, 0.4); border-radius: 50%;
            transition: width 0.1s, height 0.1s;
        }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: cyan; transform: translate(-50%, -50%); border-radius: 50%; box-shadow: 0 0 4px cyan;}

        .stat-box { 
            background: rgba(10, 25, 40, 0.85); border: 2px solid #0ff; 
            padding: 15px; border-radius: 2px; text-shadow: 0 0 8px #0ff; 
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); 
            min-width: 120px;
        }
        .stat-label { font-size: 10px; color: #aaa; margin-bottom: 8px; display: block; letter-spacing: 1px;}
        .stat-value { font-size: 28px; color: #fff; display: block;}
        
        #ammo-bar-container { width: 100%; height: 8px; background: #222; margin-top: 8px; border: 1px solid #555; }
        #ammo-fill { height: 100%; background: #0ff; width: 100%; transition: width 0.1s linear, background 0.3s; box-shadow: 0 0 5px #0ff;}

        /* LOADING & START SCREEN */
        #blocker { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.9) 100%); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            pointer-events: auto; z-index: 10; backdrop-filter: blur(2px);
        }

        #start-screen-content { text-align: center; color: white; position: relative; width: 60%; max-width: 600px;}
        
        h1 { 
            font-size: 40px; text-transform: uppercase; letter-spacing: 5px; color: #fff;
            text-shadow: 4px 4px 0px #0055aa; margin-bottom: 10px; line-height: 1.2;
        }
        
        .subtitle { font-size: 14px; color: cyan; margin-bottom: 40px; letter-spacing: 2px; opacity: 0.8; }
        .controls { font-size: 12px; color: #888; margin-top: 30px; line-height: 24px; border-top: 1px solid #333; padding-top: 20px;}
        .key { color: #fff; background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #555;}

        /* LOADING BAR */
        #loading-container { width: 100%; margin: 20px 0; display: block;}
        #loading-label { font-size: 12px; color: #aaa; margin-bottom: 10px; text-align: left; display: block;}
        #loading-bar-bg { width: 100%; height: 20px; background: #111; border: 2px solid #333; padding: 2px;}
        #loading-bar-fill { height: 100%; background: #00ffaa; width: 0%; box-shadow: 0 0 10px #00ffaa; transition: width 0.1s linear;}
        
        /* CLICK TO START BUTTON (Hidden initially) */
        #start-btn { 
            display: none; padding: 20px 40px; background: transparent; 
            border: 2px solid #0ff; color: #0ff; font-family: inherit; font-size: 20px; 
            cursor: pointer; text-transform: uppercase; transition: all 0.2s;
            margin: 0 auto;
        }
        #start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff;}

    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    
    <div id="ui-layer">
        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">OPERATIVE SCORE</span>
                <span class="stat-value" id="score">0000</span>
            </div>
        </div>
        
        <div id="crosshair"></div>

        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">VITALS</span>
                <span class="stat-value" id="health">100%</span>
            </div>
            <div class="stat-box" style="text-align: right; min-width: 180px;">
                <span class="stat-label">AMMUNITION</span>
                <span class="stat-value" id="ammo">30 / 30</span>
                <div id="ammo-bar-container"><div id="ammo-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="blocker">
        <div id="start-screen-content">
            <h1>Peak Protocol</h1>
            <div class="subtitle">TACTICAL ALPINE ASSAULT</div>
            
            <div id="loading-container">
                <span id="loading-label">ESTABLISHING UPLINK... <span id="percent">0%</span></span>
                <div id="loading-bar-bg">
                    <div id="loading-bar-fill"></div>
                </div>
            </div>

            <button id="start-btn">INITIALIZE</button>

            <div class="controls" id="controls-text" style="display:none;">
                <span class="key">WASD</span> MOVE &nbsp; <span class="key">SHIFT</span> SPRINT &nbsp; <span class="key">SPACE</span> JUMP<br>
                <span class="key">L-CLICK</span> FIRE &nbsp; <span class="key">R</span> RELOAD
            </div>
        </div>
    </div>

    <!-- MODULES -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. PROCEDURAL GENERATORS (Canvas API) ---
        // Generates detailed texture maps in memory
        function createProceduralTexture(type, hexColor) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base fill
            ctx.fillStyle = hexColor;
            ctx.fillRect(0,0,size,size);
            
            // Noise/Grit
            for(let i=0; i<40000; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.05})`;
                ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
            }

            if(type === 'rock') {
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                for(let i=0; i<20; i++){
                    ctx.lineWidth = Math.random()*5;
                    ctx.beginPath();
                    ctx.moveTo(Math.random()*size, Math.random()*size);
                    ctx.lineTo(Math.random()*size, Math.random()*size);
                    ctx.stroke();
                }
            } else if (type === 'snow') {
                ctx.fillStyle = "rgba(255,255,255,0.1)";
                for(let i=0; i<100; i++) ctx.fillRect(Math.random()*size, Math.random()*size, 4, 4);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        const matRock = new THREE.MeshStandardMaterial({ 
            map: createProceduralTexture('rock', '#555555'), roughness: 0.9, metalness: 0.1 
        });
        const matSnow = new THREE.MeshStandardMaterial({ 
            map: createProceduralTexture('snow', '#ddddff'), roughness: 0.4, metalness: 0.1,
            color: 0xeeeeff 
        });

        // --- 2. SETUP ---
        const scene = new THREE.Scene();
        // Custom gradient background simulation via fog color matching
        const fogColor = new THREE.Color(0xcceeff);
        scene.background = new THREE.Color(0x88ccff); 
        scene.fog = new THREE.Fog(0x88ccff, 10, 180);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444455, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffee, 1.0);
        dirLight.position.set(100, 150, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.far = 400;
        dirLight.shadow.bias = -0.0001;
        
        // Shadow Camera bounds coverage
        const d = 100;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- 3. TERRAIN GENERATION (The Mountain) ---
        const chunkObjects = [];
        
        function createTerrain() {
            // Skydome for mountain vibes
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition + vec3(0, 50, 0) ).y;
                    gl_FragColor = mix( vec4(0.8,0.9,1.0,1.0), vec4(0.05,0.2,0.5,1.0), max(0.0, 1.0 - h*1.5) );
                }
            `;
            const skyGeo = new THREE.SphereGeometry(600, 32, 15);
            const skyMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader, side: THREE.BackSide, fog: false });
            scene.add(new THREE.Mesh(skyGeo, skyMat));

            // Blocks for terrain (Voxel-ish style)
            const floorY = -2;
            
            // Ground Plane
            const planeGeo = new THREE.PlaneGeometry(300, 300);
            const plane = new THREE.Mesh(planeGeo, matSnow);
            plane.rotation.x = -Math.PI/2;
            plane.position.y = floorY;
            plane.receiveShadow = true;
            scene.add(plane);
            chunkObjects.push(plane);

            // Mountain Blocks
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            
            // Generate some random clustered heights (like Perlin noise but simpler)
            for(let x=-50; x<=50; x+=5) {
                for(let z=-50; z<=50; z+=5) {
                    if (Math.abs(x) < 5 && Math.abs(z) < 5) continue; // Clear start area

                    const dist = Math.sqrt(x*x + z*z);
                    const height = (Math.sin(x*0.1) + Math.cos(z*0.1)) * 4 + (Math.random() * 5);
                    const scaleY = Math.max(2, Math.abs(height) * (dist/20) + 2); // Taller at edges
                    
                    if (scaleY > 3) {
                        const block = new THREE.Mesh(boxGeo, scaleY > 8 ? matRock : matSnow);
                        block.position.set(x + Math.random()*2, scaleY/2 + floorY, z + Math.random()*2);
                        block.scale.set(4 + Math.random()*3, scaleY, 4 + Math.random()*3);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        scene.add(block);
                        chunkObjects.push(block);
                    }
                }
            }
        }
        createTerrain();

        // --- 4. PLAYER & WEAPON ---
        const controls = new PointerLockControls(camera, document.body);
        const playerPos = new THREE.Vector3();
        const playerVel = new THREE.Vector3();
        const inputs = { w:false, a:false, s:false, d:false, space:false, shift:false };

        // Procedural Weapon Construction
        const weaponGroup = new THREE.Group();
        // Body
        const wMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2, metalness: 0.8 });
        const wBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.6), wMat);
        // Barrel
        const wBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.7), wMat);
        wBarrel.rotation.x = Math.PI/2;
        wBarrel.position.z = -0.35;
        // Scope
        const wScope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.2, 8), new THREE.MeshStandardMaterial({color: 0x111111}));
        wScope.rotation.x = Math.PI/2;
        wScope.position.set(0, 0.12, -0.1);
        // Mag
        const wMag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.25, 0.12), new THREE.MeshStandardMaterial({color:0x111111}));
        wMag.position.set(0, -0.15, 0);

        weaponGroup.add(wBody, wBarrel, wScope, wMag);
        weaponGroup.position.set(0.25, -0.25, -0.5); // Default pos
        camera.add(weaponGroup);
        scene.add(camera);

        const weapon = {
            ammo: 30, maxAmmo: 30, 
            reloading: false, 
            nextFire: 0, rate: 100,
            recoil: 0,
            basePos: new THREE.Vector3(0.25, -0.25, -0.5)
        };

        // --- 5. ENEMY SYSTEM ---
        const enemies = [];
        const enemyGeo = new THREE.Group();
        
        // Construct Enemy Model "Soldier"
        function createSoldierTemplate() {
            const root = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x556644, roughness:0.8 }); // Green camo
            const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 0.6), mat);
            torso.position.y = 0.9;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({color:0x221111}));
            head.position.y = 1.55;
            const limbGeo = new THREE.CapsuleGeometry(0.12, 0.5);
            const legL = new THREE.Mesh(limbGeo, mat); legL.position.set(-0.2, 0.25, 0);
            const legR = new THREE.Mesh(limbGeo, mat); legR.position.set(0.2, 0.25, 0);
            
            root.add(torso, head, legL, legR);
            return root;
        }

        const soldierProto = createSoldierTemplate();

        function spawnEnemy() {
            if(enemies.length > 6) return; // Limit active count
            const ent = soldierProto.clone();
            
            // Random Pos around player
            const ang = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random()*20;
            ent.position.set(
                playerPos.x + Math.cos(ang)*dist,
                5, // Start high and drop
                playerPos.z + Math.sin(ang)*dist
            );
            
            ent.userData = { health: 3, lastAtk: 0, dy: 0 };
            scene.add(ent);
            enemies.push(ent);
        }

        // --- 6. LOGIC & PARTICLES ---
        const bullets = []; // Tracers
        const particles = [];

        function spawnParticles(pos, count, color) {
            const mat = new THREE.MeshBasicMaterial({color: color});
            const geo = new THREE.BoxGeometry(0.08,0.08,0.08);
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)).normalize().multiplyScalar(5 + Math.random()*5),
                    life: 0.5
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateUI() {
            document.getElementById('ammo').innerText = `${weapon.ammo} / ${weapon.maxAmmo}`;
            document.getElementById('ammo-fill').style.width = (weapon.ammo / weapon.maxAmmo * 100) + "%";
            
            if(weapon.ammo === 0) document.getElementById('ammo-fill').style.background = 'red';
            else document.getElementById('ammo-fill').style.background = '#0ff';
        }

        // --- 7. INPUT HANDLERS ---
        document.addEventListener('keydown', (e) => {
            const code = e.code.toLowerCase();
            if (code === 'keyw') inputs.w = true;
            if (code === 'keya') inputs.a = true;
            if (code === 'keys') inputs.s = true;
            if (code === 'keyd') inputs.d = true;
            if (code === 'space') inputs.space = true;
            if (code === 'shiftleft') inputs.shift = true;
            if (code === 'keyr') reload();
        });
        document.addEventListener('keyup', (e) => {
            const code = e.code.toLowerCase();
            if (code === 'keyw') inputs.w = false;
            if (code === 'keya') inputs.a = false;
            if (code === 'keys') inputs.s = false;
            if (code === 'keyd') inputs.d = false;
            if (code === 'space') inputs.space = false;
            if (code === 'shiftleft') inputs.shift = false;
        });

        let isMouseDown = false;
        document.addEventListener('mousedown', () => isMouseDown = true);
        document.addEventListener('mouseup', () => isMouseDown = false);

        function reload() {
            if (weapon.reloading || weapon.ammo === weapon.maxAmmo) return;
            weapon.reloading = true;
            
            // UI Feedback
            const container = document.getElementById('ammo-bar-container');
            container.style.borderColor = "red";
            
            // Animation Helper
            let progress = 0;
            const startRot = weaponGroup.rotation.x;
            const endRot = -Math.PI/3;

            const reloadInt = setInterval(() => {
                progress += 0.05;
                // Animate down
                if(progress < 0.5) weaponGroup.rotation.x = THREE.MathUtils.lerp(startRot, endRot, progress*2);
                // Animate up
                else weaponGroup.rotation.x = THREE.MathUtils.lerp(endRot, 0, (progress-0.5)*2);

                if (progress >= 1) {
                    weapon.ammo = weapon.maxAmmo;
                    weapon.reloading = false;
                    container.style.borderColor = "#555";
                    updateUI();
                    clearInterval(reloadInt);
                }
            }, 50); // Fast simple interval
        }

        function shoot(time) {
            if (weapon.ammo <= 0) {
                if(!weapon.reloading) reload();
                return;
            }
            if (weapon.reloading || time < weapon.nextFire) return;

            weapon.nextFire = time + weapon.rate;
            weapon.ammo--;
            weapon.recoil = 0.1;
            updateUI();

            // Create Tracer
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            let endPoint;
            
            // Check Hits
            if(intersects.length > 0) {
                const hit = intersects.find(x => x.object.parent !== weaponGroup); // Ignore self
                if(hit) {
                    endPoint = hit.point;
                    
                    // Hit Enemy?
                    let obj = hit.object;
                    while(obj.parent && obj.parent.type === 'Group' && obj.parent !== scene) obj = obj.parent;
                    
                    if (enemies.includes(obj)) {
                        obj.userData.health--;
                        spawnParticles(hit.point, 5, 0xff0000);
                        if (obj.userData.health <= 0) {
                            spawnParticles(obj.position, 20, 0x00ff00);
                            scene.remove(obj);
                            enemies.splice(enemies.indexOf(obj), 1);
                            let score = parseInt(document.getElementById('score').innerText);
                            document.getElementById('score').innerText = (score+100).toString().padStart(4,'0');
                        }
                    } else {
                        spawnParticles(hit.point, 5, 0xcccccc);
                    }
                } else {
                    endPoint = raycaster.ray.at(100, new THREE.Vector3());
                }
            } else {
                endPoint = raycaster.ray.at(100, new THREE.Vector3());
            }

            // Visual Tracer
            const lineGeo = new THREE.BufferGeometry().setFromPoints([weaponGroup.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0.05, 0, -0.5)), endPoint]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0xffff00}));
            scene.add(line);
            setTimeout(() => scene.remove(line), 50);

            // Cam recoil
            camera.rotation.x += 0.01; 
            weaponGroup.position.z += 0.05;
        }

        // --- 8. GAME LOOP ---
        const clock = new THREE.Clock();
        
        // Cinematic State
        let isCinematic = true;
        let cinematicTimer = 0;
        const CINEMATIC_DURATION = 5.0; 
        const camStartPos = new THREE.Vector3(0, 100, 100);
        const camEndPos = new THREE.Vector3(0, 2, 0);

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(0.05, clock.getDelta());
            const now = Date.now();

            if (isCinematic) {
                cinematicTimer += dt;
                const p = Math.min(1.0, cinematicTimer / CINEMATIC_DURATION);
                
                // --- PROGRESS BAR UPDATE ---
                const pct = Math.floor(p * 100);
                document.getElementById('percent').innerText = pct + '%';
                document.getElementById('loading-bar-fill').style.width = pct + '%';

                // Curve path
                const curveP = p * p * (3 - 2 * p); // Smoothstep
                camera.position.lerpVectors(camStartPos, camEndPos, curveP);
                camera.lookAt(0, 0, 0);

                if (p >= 1) {
                    // Loading complete
                    document.getElementById('loading-label').innerText = "SYSTEMS ONLINE";
                    document.getElementById('loading-label').style.color = "#0f0";
                    document.getElementById('loading-bar-fill').style.background = "#fff";
                    document.getElementById('start-btn').style.display = 'block'; // Show button
                    document.getElementById('controls-text').style.display = 'block'; 
                    
                    // Unlock button
                    document.getElementById('start-btn').onclick = () => {
                        isCinematic = false;
                        document.getElementById('blocker').style.display = 'none';
                        controls.lock();
                    };

                    // Just hover slightly while waiting for click
                    camera.position.y = 2 + Math.sin(now*0.001)*0.2;
                }
                renderer.render(scene, camera);
                return; 
            }

            // --- GAMEPLAY ---

            // Controls
            if (controls.isLocked) {
                const speed = (inputs.shift ? 10.0 : 5.0) * dt;
                
                // Friction
                playerVel.x -= playerVel.x * 10.0 * dt;
                playerVel.z -= playerVel.z * 10.0 * dt;
                // Gravity
                playerVel.y -= 30 * dt;

                const fwd = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
                camera.getWorldDirection(right); right.cross(new THREE.Vector3(0,1,0)).normalize(); right.y=0;

                if(inputs.w) playerVel.addScaledVector(fwd, speed * 200 * dt);
                if(inputs.s) playerVel.addScaledVector(fwd, -speed * 200 * dt);
                if(inputs.d) playerVel.addScaledVector(right, speed * 200 * dt); // Fixed left/right inverse
                if(inputs.a) playerVel.addScaledVector(right, -speed * 200 * dt);

                if(inputs.space && Math.abs(playerVel.y) < 0.2) {
                     playerVel.y = 12; // Jump
                }

                controls.moveRight(playerVel.x * dt); // Library handles local vs world quirk, use simplified Vel logic usually but let's just stick manually
                controls.getObject().position.add(new THREE.Vector3(playerVel.x*dt, 0, playerVel.z*dt));
                controls.getObject().position.y += playerVel.y * dt;

                // Floor Hit Test
                if (controls.getObject().position.y < 2) {
                    playerVel.y = 0;
                    controls.getObject().position.y = 2;
                }
                
                playerPos.copy(controls.getObject().position); // Update tracking var

                // Firing
                if(isMouseDown) shoot(now);

                // Spawning
                if(Math.random() < 0.005) spawnEnemy();
            }

            // Update Weapon Smoothness
            const bob = (inputs.w||inputs.a||inputs.s||inputs.d) ? Math.sin(now * 0.015)*0.05 : Math.sin(now*0.005)*0.01;
            weaponGroup.position.y = THREE.MathUtils.lerp(weaponGroup.position.y, weapon.basePos.y + bob, 0.1);
            weaponGroup.position.x = THREE.MathUtils.lerp(weaponGroup.position.x, weapon.basePos.x + bob*0.5, 0.1);
            weaponGroup.position.z = THREE.MathUtils.lerp(weaponGroup.position.z, weapon.basePos.z + weapon.recoil, 0.2); // Recoil return
            weapon.recoil = Math.max(0, weapon.recoil - dt);

            // Enemy AI
            enemies.forEach(e => {
                // Gravity
                const rayDown = new THREE.Raycaster(e.position, new THREE.Vector3(0,-1,0));
                const hits = rayDown.intersectObjects(chunkObjects);
                
                let targetY = 1.0;
                if(hits.length>0) targetY = hits[0].point.y + 0.1;
                
                // Move to player
                e.lookAt(playerPos.x, e.position.y, playerPos.z);
                const dir = new THREE.Vector3().subVectors(playerPos, e.position).normalize();
                e.position.add(dir.multiplyScalar(3.5 * dt));
                
                if (e.position.y > targetY) e.position.y -= 9.8 * dt; // Fall
                if (e.position.y < targetY) e.position.y = targetY; // Land

                // Animation bob
                e.children[0].position.y = 0.9 + Math.sin(now*0.01)*0.05;

                // Attack
                if(e.position.distanceTo(playerPos) < 2) {
                    if (now - e.userData.lastAtk > 1000) {
                        e.userData.lastAtk = now;
                        document.getElementById('damage-overlay').style.boxShadow = "inset 0 0 100px red";
                        setTimeout(() => document.getElementById('damage-overlay').style.boxShadow = "none", 100);
                        
                        let hp = parseInt(document.getElementById('health').innerText);
                        hp -= 10;
                        document.getElementById('health').innerText = hp + '%';
                        if(hp <= 0) {
                             document.getElementById('start-btn').innerText = "RESTART MISSION";
                             document.getElementById('start-screen-content').querySelector('h1').innerText = "K.I.A.";
                             document.getElementById('blocker').style.display = 'flex';
                             controls.unlock();
                             location.reload(); 
                        }
                    }
                }
            });

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.userData.life -= dt;
                p.position.addScaledVector(p.userData.vel, dt);
                p.rotation.x += dt;
                if(p.userData.life <= 0) { scene.remove(p); particles.splice(i,1); }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>