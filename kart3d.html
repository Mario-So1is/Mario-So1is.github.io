<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Ops: Infinite Summit</title>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Chakra Petch', sans-serif; user-select: none; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 5; }
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; box-shadow: inset 0 0 0 0 rgba(220, 20, 60, 0); transition: box-shadow 0.1s; pointer-events: none; z-index: 4; mix-blend-mode: multiply;}
        
        /* HUD */
        .hud-row { padding: 30px; display: flex; justify-content: space-between; align-items: flex-end; }
        
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: cyan;
            transform: translate(-50%, -50%); border-radius: 50%; box-shadow: 0 0 4px cyan;
        }
        #crosshair-circle {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            border: 1px solid rgba(0,255,255,0.3); border-radius: 50%; transform: translate(-50%, -50%);
            transition: width 0.1s, height 0.1s;
        }

        .stat-box { 
            background: rgba(0, 0, 0, 0.6); border-left: 4px solid #0ff; 
            padding: 10px 20px; text-shadow: 0 0 5px rgba(0,255,255,0.5); 
            backdrop-filter: blur(4px); transform: skewX(-10deg);
        }
        .stat-label { font-size: 10px; color: #88ccff; margin-bottom: 5px; display: block; letter-spacing: 2px;}
        .stat-value { font-size: 24px; color: #fff; display: block; font-weight: 700;}
        
        #ammo-fill { height: 6px; background: #0ff; width: 100%; margin-top:5px; transition: width 0.1s linear, background 0.3s; box-shadow: 0 0 5px #0ff;}

        /* LOADING & START SCREEN */
        #blocker { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #050505; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            pointer-events: auto; z-index: 10;
        }

        #start-screen-content { text-align: center; color: white; width: 80%; max-width: 800px; position: relative;}
        
        h1 { 
            font-size: 60px; text-transform: uppercase; letter-spacing: 10px; color: #fff; margin: 0;
            background: linear-gradient(180deg, #fff, #555); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .subtitle { font-size: 16px; color: cyan; margin-bottom: 60px; letter-spacing: 4px; text-transform: uppercase;}

        /* LOADING BAR */
        #loading-container { width: 100%; max-width: 400px; margin: 0 auto; display: block; position: relative;}
        #loading-bar-bg { width: 100%; height: 2px; background: #333; margin-top: 10px;}
        #loading-bar-fill { height: 100%; background: #0ff; width: 0%; box-shadow: 0 0 20px #0ff; transition: width 0.2s;}
        
        #start-btn { 
            display: none; padding: 15px 50px; background: rgba(0,255,255,0.1); 
            border: 1px solid #0ff; color: #0ff; font-family: inherit; font-size: 18px; 
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            margin: 30px auto; transition: all 0.2s;
        }
        #start-btn:hover { background: #0ff; color: #000; }

        /* VIGNETTE */
        #vignette {
            position: fixed; top:0; left:0; width:100%; height:100%; pointer-events:none;
            background: radial-gradient(circle, transparent 50%, black 150%);
            z-index: 3;
        }

    </style>
</head>
<body>

    <div id="vignette"></div>
    <div id="damage-overlay"></div>
    
    <div id="ui-layer">
        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">OP // SCORE</span>
                <span class="stat-value" id="score">0000</span>
            </div>
        </div>
        
        <div id="crosshair-circle"></div>
        <div id="crosshair"></div>

        <div class="hud-row">
            <div class="stat-box">
                <span class="stat-label">VITALS</span>
                <span class="stat-value" id="health">100%</span>
            </div>
            <div class="stat-box" style="text-align: right; min-width: 150px;">
                <span class="stat-label">MAGAZINE</span>
                <span class="stat-value" id="ammo">30</span>
                <div id="ammo-fill"></div>
            </div>
        </div>
    </div>

    <div id="blocker">
        <div id="start-screen-content">
            <h1>TITAN FALLOUT</h1>
            <div class="subtitle">Procedural Alpine Combat</div>
            
            <div id="loading-container">
                <span style="font-size:10px; color:#555; letter-spacing:2px;">GENERATING TERRAIN... <span id="percent">0%</span></span>
                <div id="loading-bar-bg"><div id="loading-bar-fill"></div></div>
            </div>

            <button id="start-btn">DEPLOY</button>
            <div style="margin-top:20px; font-size: 10px; color:#444;">WASD MOVE | SHIFT SPRINT | R RELOAD | CLICK FIRE</div>
        </div>
    </div>

    <!-- MODULES -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. PROCEDURAL TERRAIN ENGINE (MATH BASED) ---
        
        // Simplex-ish pseudo random noise for vastness without library
        const _seed = 1337;
        function fract(x) { return x - Math.floor(x); }
        function hash(n) { return fract(Math.sin(n) * 43758.5453123); }
        
        function noise(x, z) {
            const floorX = Math.floor(x);
            const floorZ = Math.floor(z);
            const s = floorX + floorZ * 57;
            const a = hash(s);
            const b = hash(s + 1);
            const c = hash(s + 57);
            const d = hash(s + 58);
            
            const fX = fract(x);
            const fZ = fract(z);
            
            // Cubic smoothing
            const smoothX = fX * fX * (3.0 - 2.0 * fX);
            const smoothZ = fZ * fZ * (3.0 - 2.0 * fZ);
            
            return (a + (b - a) * smoothX + (c - a) * smoothZ + (a - b - c + d) * smoothX * smoothZ);
        }

        // The master height function: Returns ground height at X,Z
        // combines multiple "Octaves" of noise for realism
        function getTerrainHeight(x, z) {
            let y = 0;
            // Major peaks (Large structures)
            y += noise(x * 0.003, z * 0.003) * 120; 
            // Medium hills
            y += noise(x * 0.01, z * 0.01) * 30;
            // Rocky details
            y += noise(x * 0.05, z * 0.05) * 5;
            
            // Valleys flattening
            if(y < 10) y *= 0.8; 

            return Math.max(-50, y);
        }

        // --- 2. SETUP ---
        const scene = new THREE.Scene();
        // Fog mimics atmospheric depth
        const fogColor = new THREE.Color(0xaaccff);
        scene.background = fogColor;
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0025);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 2000); // 65 FOV feels more "AAA"
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); // Performance tuning
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444455, 0.4);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        dirLight.position.set(300, 500, 200);
        dirLight.castShadow = true;
        
        // Massive Shadow Config for Vast Maps
        const camSize = 300;
        dirLight.shadow.camera.left = -camSize; dirLight.shadow.camera.right = camSize;
        dirLight.shadow.camera.top = camSize; dirLight.shadow.camera.bottom = -camSize;
        dirLight.shadow.camera.near = 50; dirLight.shadow.camera.far = 1000;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);

        // --- 3. GENERATE VISUAL MESH ---
        // We create one huge chunk.
        const TERRAIN_SIZE = 1200;
        const RES = 256; // Vertex resolution (256x256)
        
        const groundGeo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, RES, RES);
        groundGeo.rotateX(-Math.PI / 2);

        // Displace vertices based on our Math Function
        const colors = [];
        const posAttr = groundGeo.attributes.position;
        const vert = new THREE.Vector3();
        const colorRock = new THREE.Color(0x555555);
        const colorSnow = new THREE.Color(0xffffff);
        const colorDirt = new THREE.Color(0x3a3a3a);

        for (let i = 0; i < posAttr.count; i++) {
            vert.fromBufferAttribute(posAttr, i);
            const h = getTerrainHeight(vert.x, vert.z);
            posAttr.setY(i, h);

            // Simple Slope Calculation (neighbors would be better but this works for style)
            // Color based on height and randomness
            let c = colorRock.clone();
            if(h > 80) c.lerp(colorSnow, (h-80)/40); // Snow caps
            else if (h < 20) c.lerp(colorDirt, 0.8); // Dirt valleys
            
            // Add noise to color
            c.r += (Math.random()-0.5)*0.1;
            c.g += (Math.random()-0.5)*0.1;
            c.b += (Math.random()-0.5)*0.1;

            colors.push(c.r, c.g, c.b);
        }

        groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        groundGeo.computeVertexNormals();

        const groundMat = new THREE.MeshStandardMaterial({ 
            vertexColors: true, 
            roughness: 0.9, 
            metalness: 0.1,
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.receiveShadow = true;
        scene.add(ground);

        // Water/Cloud Layer (just for visuals at low Y)
        const cloudGeo = new THREE.PlaneGeometry(2000, 2000);
        const cloudMat = new THREE.MeshBasicMaterial({color: 0xeeeeff, opacity:0.3, transparent:true, side: THREE.DoubleSide});
        const cloudPlane = new THREE.Mesh(cloudGeo, cloudMat);
        cloudPlane.rotation.x = -Math.PI/2;
        cloudPlane.position.y = 5; // Low level clouds/mist
        scene.add(cloudPlane);


        // --- 4. PLAYER PHYSICS ENGINE (Ray/Height Checks) ---
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const playerSpeed = 8.0; // Units per second
        let canJump = false;
        
        // Physics Consts
        const GRAVITY = 35.0;
        const JUMP_FORCE = 15.0;
        const MAX_SLOPE_CLIMB = 1.2; // How steep of a step can we take instantly?
        const PLAYER_HEIGHT = 2.0;
        
        // --- 5. WEAPON & FX ---
        const weaponGroup = new THREE.Group();
        // Weapon Styling
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.4 });
        const gBody = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.5), gunMat);
        const gGrip = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.1), gunMat); gGrip.position.set(0,-0.1,0.1);
        const gMag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.25, 0.1), new THREE.MeshStandardMaterial({color:0x333333})); gMag.position.set(0,-0.2,0);
        const gSight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.04), new THREE.MeshStandardMaterial({color:0x00ff00, emissive:0x00ff00})); gSight.position.set(0, 0.07, 0.2);
        
        weaponGroup.add(gBody, gGrip, gMag, gSight);
        weaponGroup.position.set(0.2, -0.3, -0.4);
        camera.add(weaponGroup);
        scene.add(camera);

        const weaponState = {
            ammo: 30, maxAmmo: 30,
            recoil: 0, recoilRecovery: 5.0,
            rate: 90, lastShot: 0,
            reloading: false
        };

        const bullets = [];
        
        // --- 6. ENEMIES (Respects Physics) ---
        const enemies = [];
        const enemyMeshProto = new THREE.Group();
        const eMat = new THREE.MeshStandardMaterial({ color: 0xaa4444 });
        const eBody = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8), eMat); eBody.position.y = 0.9;
        const eHead = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.35), new THREE.MeshStandardMaterial({color: 0x222222})); eHead.position.set(0, 1.5, 0);
        enemyMeshProto.add(eBody, eHead);

        function spawnEnemy(x, z) {
            const ent = enemyMeshProto.clone();
            ent.position.set(x, getTerrainHeight(x, z), z);
            ent.userData = { health: 100, vel: new THREE.Vector3(), nextAtk: 0 };
            enemies.push(ent);
            scene.add(ent);
        }

        // Spawn a squad near spawn area
        for(let i=0; i<5; i++) spawnEnemy(20 + Math.random()*10, 20 + Math.random()*10);


        // --- 7. LOGIC HANDLERS ---
        const keyState = {};
        document.addEventListener('keydown', e => { 
            keyState[e.code] = true; 
            if(e.code === 'KeyR') reload();
        });
        document.addEventListener('keyup', e => keyState[e.code] = false);
        
        let mouseDown = false;
        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);


        function reload() {
            if(weaponState.reloading || weaponState.ammo === weaponState.maxAmmo) return;
            weaponState.reloading = true;
            
            // Animation
            let rot = 0;
            const interval = setInterval(() => {
                rot += 0.2;
                weaponGroup.rotation.x -= 0.1; 
                weaponGroup.rotation.z += 0.05;
                if(rot > Math.PI) {
                    clearInterval(interval);
                    weaponState.ammo = weaponState.maxAmmo;
                    document.getElementById('ammo').innerText = weaponState.ammo;
                    document.getElementById('ammo-fill').style.width = '100%';
                    weaponGroup.rotation.set(0,0,0);
                    weaponState.reloading = false;
                }
            }, 50);
        }

        function fire(time) {
            if(weaponState.reloading || weaponState.ammo <= 0) {
                if(!weaponState.reloading && weaponState.ammo <=0) reload();
                return;
            }
            if(time - weaponState.lastShot < weaponState.rate) return;

            weaponState.lastShot = time;
            weaponState.ammo--;
            weaponState.recoil += 0.15; // Kick back
            
            // Update HUD
            document.getElementById('ammo').innerText = weaponState.ammo;
            document.getElementById('ammo-fill').style.width = (weaponState.ammo / weaponState.maxAmmo * 100) + '%';

            // Hitscan
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(scene.children, true);
            
            // Visual Line
            let target = ray.ray.at(100, new THREE.Vector3());

            for(let hit of hits) {
                if(hit.object.parent && enemies.includes(hit.object.parent)) {
                    // HIT ENEMY
                    const en = hit.object.parent;
                    en.userData.health -= 35;
                    target = hit.point;
                    
                    // Flash effect
                    en.children.forEach(c => {
                         const oldHex = c.material.color.getHex();
                         c.material.color.setHex(0xffffff);
                         setTimeout(()=>c.material.color.setHex(oldHex), 50);
                    });

                    if(en.userData.health <= 0) {
                        enemies.splice(enemies.indexOf(en), 1);
                        scene.remove(en);
                        let s = parseInt(document.getElementById('score').innerText) + 100;
                        document.getElementById('score').innerText = s.toString().padStart(4,'0');
                        // Spawn replacement
                        const ang = Math.random()*6.28;
                        const dist = 30 + Math.random()*20;
                        spawnEnemy(camera.position.x + Math.cos(ang)*dist, camera.position.z + Math.sin(ang)*dist);
                    }
                    break;
                } else if (hit.object === ground) {
                    target = hit.point;
                    break; // Hit ground
                }
            }

            const geo = new THREE.BufferGeometry().setFromPoints([
                weaponGroup.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,0.05,-0.5)),
                target
            ]);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color: 0xffffaa}));
            scene.add(line);
            setTimeout(()=>scene.remove(line), 40);
        }


        // --- 8. MAIN LOOP ---
        const clock = new THREE.Clock();
        
        // Cinematic Vars
        let isCinematic = true;
        let cinematicProgress = 0;
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3( -200, 300, 200 ),
            new THREE.Vector3( 0, 150, 0 ),
            new THREE.Vector3( 20, 120, -20 ),
            new THREE.Vector3( 50, getTerrainHeight(50,50)+2, 50 ) // Land
        ]);

        function updateGame() {
            const dt = Math.min(0.05, clock.getDelta());
            const now = Date.now();

            // CINEMATIC MODE
            if(isCinematic) {
                cinematicProgress += dt * 0.15; // Speed
                const pt = curve.getPointAt(Math.min(1, cinematicProgress));
                camera.position.copy(pt);
                camera.lookAt(50, getTerrainHeight(50,50), 50);
                
                // Loading bar visuals
                const pct = Math.floor(Math.min(1, cinematicProgress) * 100);
                document.getElementById('percent').innerText = pct + '%';
                document.getElementById('loading-bar-fill').style.width = pct + '%';

                if(cinematicProgress >= 1) {
                    document.getElementById('loading-container').style.display = 'none';
                    document.getElementById('start-btn').style.display = 'block';
                    
                    // Simple hover
                    camera.position.y = getTerrainHeight(50,50) + 5 + Math.sin(now*0.001);
                }
                
                // Interaction to start
                document.getElementById('start-btn').onclick = () => {
                    isCinematic = false;
                    document.getElementById('blocker').style.display = 'none';
                    controls.lock();
                    // Teleport player to start
                    controls.getObject().position.set(50, getTerrainHeight(50,50)+5, 50);
                };
                
                renderer.render(scene, camera);
                requestAnimationFrame(updateGame);
                return;
            }

            // GAME MODE
            if(controls.isLocked) {
                
                // 1. Movement Logic (Respecting Slope)
                // Determine intended movement direction
                const speed = (keyState['ShiftLeft'] ? 16 : 8);
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                // Extract camera direction flattened on XZ
                camera.getWorldDirection(forward); forward.y=0; forward.normalize();
                camera.getWorldDirection(right); right.crossVectors(camera.up, forward).normalize(); right.multiplyScalar(-1);

                const moveDir = new THREE.Vector3();
                if(keyState['KeyW']) moveDir.add(forward);
                if(keyState['KeyS']) moveDir.sub(forward);
                if(keyState['KeyD']) moveDir.add(right); // Fixed axis
                if(keyState['KeyA']) moveDir.sub(right);
                
                if(moveDir.length() > 0) moveDir.normalize().multiplyScalar(speed * dt);

                // Proposed next position (Horizontal)
                const currentPos = controls.getObject().position;
                const nextX = currentPos.x + moveDir.x;
                const nextZ = currentPos.z + moveDir.z;
                
                // COLLISION: Slope Check
                const currentGround = getTerrainHeight(currentPos.x, currentPos.z);
                const nextGround = getTerrainHeight(nextX, nextZ);
                const slope = nextGround - currentGround; // Positive means going up

                // Prevent moving off edge
                if (Math.abs(nextX) > TERRAIN_SIZE/2 - 10 || Math.abs(nextZ) > TERRAIN_SIZE/2 - 10) {
                    velocity.x = 0; velocity.z = 0; // Wall
                } 
                // Wall Climb check (Physics collision)
                else if (slope > MAX_SLOPE_CLIMB) {
                    // Wall! Halt horizontal movement
                    velocity.x = 0; velocity.z = 0;
                } else {
                    controls.getObject().position.x = nextX;
                    controls.getObject().position.z = nextZ;
                }

                // Vertical Physics (Gravity)
                if (keyState['Space'] && canJump) {
                    velocity.y = JUMP_FORCE;
                    canJump = false;
                }
                
                velocity.y -= GRAVITY * dt;
                
                // Apply Gravity
                controls.getObject().position.y += velocity.y * dt;

                // Ground Clamping
                const groundHeight = getTerrainHeight(controls.getObject().position.x, controls.getObject().position.z);
                
                if (controls.getObject().position.y < groundHeight + PLAYER_HEIGHT) {
                    controls.getObject().position.y = groundHeight + PLAYER_HEIGHT;
                    velocity.y = 0;
                    canJump = true;
                }

                // Recoil Handling
                if(mouseDown) fire(now);
                weaponState.recoil = Math.max(0, weaponState.recoil - dt * weaponState.recoilRecovery);
                
                // Procedural Animation (Sway + Recoil)
                const moveBob = moveDir.lengthSq() > 0 ? Math.sin(now * 0.015) * 0.05 : Math.sin(now*0.005) * 0.01;
                
                weaponGroup.position.x = THREE.MathUtils.lerp(weaponGroup.position.x, 0.2 + moveBob, 0.1);
                weaponGroup.position.y = THREE.MathUtils.lerp(weaponGroup.position.y, -0.3 + Math.abs(moveBob) + (velocity.y * -0.01), 0.1);
                weaponGroup.position.z = THREE.MathUtils.lerp(weaponGroup.position.z, -0.4 + weaponState.recoil, 0.2);
                
                camera.rotation.x -= weaponState.recoil * 0.01; // Simple recoil influence on cam view

                // Update Enemies
                enemies.forEach(e => {
                    // Logic: Follow Player, respect ground
                    const dist = e.position.distanceTo(currentPos);
                    
                    if(dist < 50) { // Active range
                        // Horizontal Move
                        const dir = new THREE.Vector3().subVectors(currentPos, e.position).normalize();
                        dir.y = 0; // Flatten
                        
                        const nextEX = e.position.x + dir.x * 4 * dt;
                        const nextEZ = e.position.z + dir.z * 4 * dt;
                        const nextEHeight = getTerrainHeight(nextEX, nextEZ);

                        if(nextEHeight - e.position.y < 2) { // Only move if slope isn't insane
                             e.position.x = nextEX;
                             e.position.z = nextEZ;
                        }

                        // Face player
                        e.lookAt(currentPos.x, e.position.y, currentPos.z);
                        
                        // Attack
                        if(dist < 3 && now > e.userData.nextAtk) {
                            e.userData.nextAtk = now + 1000;
                            // Flash RED screen
                            const dom = document.getElementById('damage-overlay');
                            dom.style.boxShadow = "inset 0 0 100px red";
                            setTimeout(() => dom.style.boxShadow = "none", 150);
                            
                            let hp = parseInt(document.getElementById('health').innerText);
                            hp -= 15;
                            document.getElementById('health').innerText = hp + '%';
                            if(hp <= 0) location.reload();
                        }
                    }
                    
                    // Clamp to ground
                    const gh = getTerrainHeight(e.position.x, e.position.z);
                    e.position.y = gh + 0.1; 
                });
            }

            renderer.render(scene, camera);
            requestAnimationFrame(updateGame);
        }

        updateGame();

        // RESIZE HANDLER
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>