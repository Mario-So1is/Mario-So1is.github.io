<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Hyper Kart</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background: #000; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        h1 { margin: 0; font-style: italic; color: #ff3333; }
        #scoreBoard { font-size: 24px; font-weight: bold; }
        #gameOver {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border: 4px solid #ff3333;
            border-radius: 10px;
        }
        button {
            background: #ff3333; color: white; border: none;
            padding: 10px 20px; font-size: 20px; cursor: pointer; margin-top: 10px;
        }
        button:hover { background: #ff0000; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h1>HYPER KART 3D</h1>
        <div id="scoreBoard">Score: 0</div>
        <div>Use <b>Left/Right Arrows</b> to Drive</div>
    </div>

    <div id="gameOver">
        <h1>CRASHED!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

<script>
    // --- 1. SETUP THE SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky Blue
    scene.fog = new THREE.Fog(0x87CEEB, 10, 50); // Fog to hide the horizon

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 6); // Third person view
    camera.lookAt(0, 0, -5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- 2. LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- 3. THE WORLD (Ground & Grid) ---
    // We create a moving grid to simulate speed
    const gridHelper = new THREE.GridHelper(200, 50, 0xffffff, 0x555555);
    scene.add(gridHelper);
    
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Grass Green
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.1;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- 4. THE PLAYER (The Kart) ---
    const kartGroup = new THREE.Group();

    // Body
    const bodyGeo = new THREE.BoxGeometry(1, 0.5, 2);
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Mario Red
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.5;
    body.castShadow = true;
    kartGroup.add(body);

    // Wheels function
    function createWheel(x, z) {
        const wGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
        const wMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
        const wheel = new THREE.Mesh(wGeo, wMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(x, 0.3, z);
        return wheel;
    }
    kartGroup.add(createWheel(0.6, 0.6));
    kartGroup.add(createWheel(-0.6, 0.6));
    kartGroup.add(createWheel(0.6, -0.6));
    kartGroup.add(createWheel(-0.6, -0.6));

    scene.add(kartGroup);

    // --- 5. GAME LOGIC ---
    let gameActive = true;
    let score = 0;
    let speed = 0.3;
    let lateralSpeed = 0.15;
    
    // Input Handling
    const keys = { left: false, right: false };
    document.addEventListener('keydown', (e) => {
        if (e.key === "ArrowLeft") keys.left = true;
        if (e.key === "ArrowRight") keys.right = true;
    });
    document.addEventListener('keyup', (e) => {
        if (e.key === "ArrowLeft") keys.left = false;
        if (e.key === "ArrowRight") keys.right = false;
    });

    // Object Pooling (Obstacles)
    const obstacles = [];
    const coins = [];

    function spawnObstacle() {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown Box
        const mesh = new THREE.Mesh(geo, mat);
        
        // Random X position between -4 and 4
        mesh.position.x = (Math.random() * 8) - 4;
        mesh.position.y = 0.5;
        mesh.position.z = -60; // Start far away
        mesh.castShadow = true;
        
        scene.add(mesh);
        obstacles.push(mesh);
    }

    function spawnCoin() {
        const geo = new THREE.SphereGeometry(0.4, 16, 16);
        const mat = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xAA6600 }); // Gold
        const mesh = new THREE.Mesh(geo, mat);
        
        mesh.position.x = (Math.random() * 8) - 4;
        mesh.position.y = 0.5;
        mesh.position.z = -60;
        
        scene.add(mesh);
        coins.push(mesh);
    }

    // --- 6. ANIMATION LOOP ---
    let frameCount = 0;

    function animate() {
        if (!gameActive) return;

        requestAnimationFrame(animate);

        // 1. Move Grid (Illusion of speed)
        // We actually move the grid towards Z, then reset it
        gridHelper.position.z += speed;
        if (gridHelper.position.z > 2) gridHelper.position.z = 0;

        // 2. Move Player (Steering)
        if (keys.left && kartGroup.position.x > -4.5) {
            kartGroup.position.x -= lateralSpeed;
            kartGroup.rotation.z = 0.1; // Tilt effect
            kartGroup.rotation.y = 0.1; // Turn effect
        } else if (keys.right && kartGroup.position.x < 4.5) {
            kartGroup.position.x += lateralSpeed;
            kartGroup.rotation.z = -0.1;
            kartGroup.rotation.y = -0.1;
        } else {
            kartGroup.rotation.z = 0;
            kartGroup.rotation.y = 0;
        }

        // 3. Spawner
        frameCount++;
        if (frameCount % 40 === 0) spawnObstacle(); // Spawn box every 40 frames
        if (frameCount % 60 === 0) spawnCoin();     // Spawn coin every 60 frames

        // 4. Update Obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.position.z += speed;

            // Collision Check (Simple Distance)
            if (obs.position.distanceTo(kartGroup.position) < 1.2) {
                gameOver();
            }

            // Remove if behind camera
            if (obs.position.z > 5) {
                scene.remove(obs);
                obstacles.splice(i, 1);
                score++;
                speed += 0.001; // Get faster over time
                document.getElementById('scoreBoard').innerText = "Score: " + score;
            }
        }

        // 5. Update Coins
        for (let i = coins.length - 1; i >= 0; i--) {
            let coin = coins[i];
            coin.position.z += speed;
            coin.rotation.y += 0.1; // Spin effect

            // Collection Check
            if (coin.position.distanceTo(kartGroup.position) < 1.2) {
                scene.remove(coin);
                coins.splice(i, 1);
                score += 50;
                document.getElementById('scoreBoard').innerText = "Score: " + score;
            }
            // Remove if behind camera
            else if (coin.position.z > 5) {
                scene.remove(coin);
                coins.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
    }

    function gameOver() {
        gameActive = false;
        document.getElementById('finalScore').innerText = score;
        document.getElementById('gameOver').style.display = 'block';
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>