<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>APEX MOTORSPORT SIMULATION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; user-select: none; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* MENUS */
        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(20,20,30,0.9) 0%, rgba(0,0,0,1) 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { font-size: 80px; margin: 0; letter-spacing: 10px; text-transform: uppercase; 
             background: linear-gradient(45deg, #ff3333, #ffaa00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.2);
            padding: 15px 60px; font-size: 24px; color: white; margin: 10px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: all 0.2s;
            font-family: 'Rajdhani', sans-serif; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        .btn:hover { background: #ff3333; border-color: #ff3333; transform: scale(1.05); }

        /* HUD */
        #hud { display: none; pointer-events: none; }
        #speedometer {
            position: absolute; bottom: 50px; right: 50px; text-align: right;
        }
        #speed-val { font-size: 100px; font-weight: bold; color: white; line-height: 0.8; }
        #gear-val { font-size: 40px; color: #ff3333; }
        #lap-timer {
            position: absolute; top: 20px; right: 40px; font-size: 30px; color: white;
        }
        #position-display {
            position: absolute; top: 20px; left: 40px; font-size: 60px; font-weight: bold; color: white; font-style: italic;
        }
        
        /* CINEMATIC BARS */
        .cine-bar {
            position: absolute; left: 0; width: 100%; height: 0%; background: black; transition: height 1s; z-index: 10;
        }
        #bar-top { top: 0; }
        #bar-bottom { bottom: 0; }
        .cinematic-mode #bar-top, .cinematic-mode #bar-bottom { height: 12%; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        
        <div id="menu-start" class="menu-screen">
            <h1>Apex Motorsport</h1>
            <p style="color:#888; letter-spacing: 4px; margin-bottom: 40px;">REAL DRIVING SIMULATOR</p>
            <div class="btn" onclick="goToCarSelect()">Enter Race</div>
        </div>

        <div id="menu-select" class="menu-screen hidden">
            <h1>Select Vehicle</h1>
            <div style="display:flex; gap: 20px;">
                <div class="btn" onclick="selectCar('red')">Rosso Corsa</div>
                <div class="btn" onclick="selectCar('silver')">Silver Arrow</div>
                <div class="btn" onclick="selectCar('black')">Midnight Ops</div>
            </div>
        </div>

        <div id="hud">
            <div class="cine-bar" id="bar-top"></div>
            <div class="cine-bar" id="bar-bottom"></div>
            <div id="position-display">POS <span id="pos-val">1</span>/4</div>
            <div id="lap-timer">LAP <span id="lap-val">1</span>/3</div>
            <div id="speedometer">
                <div id="speed-val">0</div>
                <div id="gear-val">N</div>
                <div style="font-size:14px; color:#aaa">KM/H</div>
            </div>
        </div>
    </div>

<script>
    /**
     * APEX ENGINE CONFIGURATION
     */
    const CONFIG = {
        shadowQuality: 2048,
        trackWidth: 14,
        aiCount: 3,
        gravity: -9.8,
        cameraHeight: 2.5,
        cameraDist: 5.5
    };

    let gameState = 'MENU'; // MENU, SELECT, CINEMATIC, RACING, FINISH
    let renderer, scene, camera;
    let clock = new THREE.Clock();
    let player, trackCurve;
    let aiCars = [];
    let collidables = [];
    let selectedColor = 0xff0000;
    
    // Physics State
    const carPhys = { speed: 0, maxSpeed: 240, accel: 40, break: 80, friction: 0.98, turnSpeed: 1.5, driftFactor: 0.95 };
    const keys = { w:0, a:0, s:0, d:0 };
    
    // --- INITIALIZATION ---
    function init() {
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.005);

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffdfba, 1.5);
        sun.position.set(100, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = CONFIG.shadowQuality;
        sun.shadow.mapSize.height = CONFIG.shadowQuality;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 500;
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        scene.add(sun);

        // Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

        // Generate Assets
        createTrack();
        generateEnvironment();

        // Listeners
        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', e => handleKey(e, 1));
        window.addEventListener('keyup', e => handleKey(e, 0));

        // Start Loop
        animate();
    }

    // --- GAME FLOW CONTROL ---
    window.goToCarSelect = function() {
        document.getElementById('menu-start').classList.add('hidden');
        document.getElementById('menu-select').classList.remove('hidden');
        gameState = 'SELECT';
    }

    window.selectCar = function(color) {
        if(color === 'red') selectedColor = 0xc41e3a;
        if(color === 'silver') selectedColor = 0xcccccc;
        if(color === 'black') selectedColor = 0x111111;
        
        document.getElementById('menu-select').classList.add('hidden');
        document.getElementById('hud').style.display = 'block';
        document.getElementById('hud').classList.add('cinematic-mode');
        
        startGame();
    }

    function startGame() {
        // Create Player
        player = new Car(scene, selectedColor, 0); // 0 offset
        player.mesh.position.copy(trackCurve.getPointAt(0));
        
        // Create AI
        const aiColors = [0x2244ff, 0x118811, 0xffaa00];
        for(let i=0; i<CONFIG.aiCount; i++) {
            let ai = new Car(scene, aiColors[i], (i+1) * 0.015); // Start slightly ahead
            ai.isAI = true;
            ai.aiOffset = (Math.random() - 0.5) * 4; // Lane variance
            ai.progress = (i+1) * 0.005; // Starting grid positions
            aiCars.push(ai);
        }

        gameState = 'CINEMATIC';
        cinematicTimer = 0;
    }

    // --- ASSET GENERATION ---
    
    // 1. Procedural Asphalt Texture
    function getAsphaltTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#333'; ctx.fillRect(0,0,512,512);
        
        // Noise
        for(let i=0; i<50000; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? '#444' : '#222';
            ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 100);
        tex.anisotropy = 16;
        return tex;
    }

    // 2. The Track (CatmullRom Spline)
    function createTrack() {
        // Define key points for a complex circuit
        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(50, 0, -100),
            new THREE.Vector3(150, 0, -150),
            new THREE.Vector3(250, 0, -50),
            new THREE.Vector3(200, 0, 50),
            new THREE.Vector3(100, 0, 100),
            new THREE.Vector3(-50, 0, 150),
            new THREE.Vector3(-150, 0, 50),
            new THREE.Vector3(-100, 0, -50)
        ];
        
        trackCurve = new THREE.CatmullRomCurve3(points);
        trackCurve.closed = true;
        
        // Visual Track Mesh
        const geometry = new THREE.TubeGeometry(trackCurve, 200, CONFIG.trackWidth, 8, true);
        const material = new THREE.MeshStandardMaterial({ 
            map: getAsphaltTexture(),
            roughness: 0.8,
            color: 0xffffff
        });
        const trackMesh = new THREE.Mesh(geometry, material);
        trackMesh.receiveShadow = true;
        // Flatten the tube to be a road
        trackMesh.scale.y = 0.05; 
        scene.add(trackMesh);

        // Curbs (Visual)
        const curbGeo = new THREE.TubeGeometry(trackCurve, 200, CONFIG.trackWidth + 1, 8, true);
        const curbMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide }); // Hacky outline
        const curb = new THREE.Mesh(curbGeo, curbMat);
        curb.position.y = -0.1;
        curb.scale.y = 0.05;
        scene.add(curb);
    }

    function generateEnvironment() {
        // Simple Ground
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ color: 0x1a2e1a, roughness: 1 })
        );
        plane.rotation.x = -Math.PI/2;
        plane.position.y = -0.5;
        plane.receiveShadow = true;
        scene.add(plane);

        // Random Trees/Buildings (Low Poly)
        const geo = new THREE.BoxGeometry(10, 50, 10);
        const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for(let i=0; i<50; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set((Math.random()-0.5)*800, 25, (Math.random()-0.5)*800);
            mesh.castShadow = true;
            scene.add(mesh);
        }
    }

    // --- CAR CLASS ---
    class Car {
        constructor(scene, color, startProgress) {
            this.mesh = new THREE.Group();
            this.velocity = new THREE.Vector3();
            this.speed = 0;
            this.progress = startProgress; // 0 to 1 along the track
            this.lap = 1;
            this.isAI = false;
            this.aiOffset = 0;
            
            // --- CAR MODEL BUILDING ---
            // Main Body
            const bodyMat = new THREE.MeshPhysicalMaterial({ 
                color: color, 
                metalness: 0.7, 
                roughness: 0.2, 
                clearcoat: 1.0, 
                clearcoatRoughness: 0.1 
            });
            const chassisGeo = new THREE.BoxGeometry(1.8, 0.6, 4.2);
            // Vertex manipulation for shape
            const pos = chassisGeo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                if(pos.getY(i) > 0) {
                    pos.setX(i, pos.getX(i) * 0.85); // Taper top
                    // Slope hood/trunk
                    if(pos.getZ(i) > 1.5 || pos.getZ(i) < -1.5) pos.setY(i, 0.1); 
                }
            }
            chassisGeo.computeVertexNormals();
            
            const chassis = new THREE.Mesh(chassisGeo, bodyMat);
            chassis.castShadow = true;
            chassis.position.y = 0.5;
            this.mesh.add(chassis);

            // Cabin
            const glass = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.5, 2.0),
                new THREE.MeshPhysicalMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1, transmission: 0.5 })
            );
            glass.position.set(0, 0.9, -0.2);
            this.mesh.add(glass);

            // Wheels
            const wGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 32);
            wGeo.rotateZ(Math.PI/2);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
            const positions = [
                {x: 0.9, z: 1.2}, {x: -0.9, z: 1.2},
                {x: 0.9, z: -1.2}, {x: -0.9, z: -1.2}
            ];
            positions.forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.position.set(p.x, 0.35, p.z);
                w.castShadow = true;
                this.mesh.add(w);
            });

            // Headlights (Point Lights for realism)
            if(!this.isAI) {
                const hl = new THREE.SpotLight(0xffffff, 2, 50, 0.5, 0.5);
                hl.position.set(0, 0.6, -2);
                hl.target.position.set(0, 0, -10);
                this.mesh.add(hl);
                this.mesh.add(hl.target);
            }

            scene.add(this.mesh);
        }

        update(dt) {
            // Get position on track curve
            const trackPos = trackCurve.getPointAt(this.progress % 1);
            const tangent = trackCurve.getTangentAt(this.progress % 1).normalize();
            
            // Calculate orientation
            // We need a 'Right' vector to apply lateral movement (steering)
            const up = new THREE.Vector3(0, 1, 0);
            const axisRight = new THREE.Vector3().crossVectors(up, tangent).normalize();

            // AI LOGIC
            let steerInput = 0;
            let accelInput = 0;

            if (this.isAI) {
                // Ideally, AI stays on track line + offset
                // Current position vs Ideal Position
                const idealPos = trackPos.clone().add(axisRight.clone().multiplyScalar(this.aiOffset));
                const distToIdeal = this.mesh.position.distanceTo(idealPos);
                
                // Simple AI speed governance
                this.speed = 180 * 0.02; // AI constant speed for simplicity
                
                // Lerp towards ideal
                this.mesh.position.lerp(idealPos, 0.05);
                this.mesh.lookAt(trackPos.clone().add(tangent.multiplyScalar(10)));
                
                // Loop progress
                this.progress += (this.speed * 0.0001); 

            } else {
                // PLAYER PHYSICS
                
                // 1. Acceleration
                if (keys.w) this.speed += carPhys.accel * dt;
                else if (keys.s) this.speed -= carPhys.break * dt;
                else this.speed *= carPhys.friction; // Coasting
                
                // Cap Speed
                this.speed = Math.max(Math.min(this.speed, carPhys.maxSpeed), -50);

                // 2. Turning
                // Rotate the CAR MESH, not just position
                if(Math.abs(this.speed) > 1) {
                    if (keys.a) this.mesh.rotation.y += carPhys.turnSpeed * dt;
                    if (keys.d) this.mesh.rotation.y -= carPhys.turnSpeed * dt;
                }

                // 3. Apply Velocity Vector based on Car Rotation (Drifting possible)
                // Get car's forward vector
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y);
                
                // Move car
                this.mesh.position.add(forward.multiplyScalar(this.speed * dt));

                // 4. Track Progress Calculation (for laps)
                // Find closest point on spline to track lap completion (Simple approximation)
                // In a real sim, we project vector. Here we just update progress blindly for lap counting visual
                // Actually, let's just drive. We need to stay somewhat near the track or we are "offroad"
                
                // Check Lap
                const d = this.mesh.position.distanceTo(trackCurve.getPointAt(0));
                if (d < 20 && this.lastD > 20) {
                   // Lap crossed logic would go here
                }
                this.lastD = d;
            }

            // --- COLLISION (Simple Sphere) ---
            if (!this.isAI) {
                aiCars.forEach(ai => {
                    const dist = this.mesh.position.distanceTo(ai.mesh.position);
                    if (dist < 3.0) {
                        // Bounce
                        const push = this.mesh.position.clone().sub(ai.mesh.position).normalize();
                        this.mesh.position.add(push.multiplyScalar(0.5));
                        this.speed *= 0.8; // Crash penalty
                    }
                });
            }
        }
    }

    // Input Handling
    function handleKey(e, state) {
        if(e.key === 'w' || e.key === 'ArrowUp') keys.w = state;
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = state;
        if(e.key === 's' || e.key === 'ArrowDown') keys.s = state;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = state;
    }

    // Resize
    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- MAIN LOOP ---
    let cinematicTimer = 0;

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        if (gameState === 'CINEMATIC') {
            cinematicTimer += dt;
            // Pan Camera around player
            const angle = cinematicTimer * 0.5;
            const camX = player.mesh.position.x + Math.sin(angle) * 15;
            const camZ = player.mesh.position.z + Math.cos(angle) * 15;
            camera.position.set(camX, 5, camZ);
            camera.lookAt(player.mesh.position);

            if (cinematicTimer > 4) {
                gameState = 'RACE';
                document.getElementById('hud').classList.remove('cinematic-mode');
            }
        }
        else if (gameState === 'RACE') {
            // Player Logic
            player.update(dt);

            // Camera Follow (Smooth Lerp)
            // Calculate desired camera position relative to car rotation
            const relativeOffset = new THREE.Vector3(0, CONFIG.cameraHeight, CONFIG.cameraDist);
            const carRotation = player.mesh.rotation.y;
            
            // Offset logic: Position behind car
            const camX = player.mesh.position.x + Math.sin(carRotation) * CONFIG.cameraDist;
            const camZ = player.mesh.position.z + Math.cos(carRotation) * CONFIG.cameraDist;
            
            // Lerp Camera
            camera.position.x += (camX - camera.position.x) * 0.1;
            camera.position.z += (camZ - camera.position.z) * 0.1;
            camera.position.y += ((player.mesh.position.y + CONFIG.cameraHeight) - camera.position.y) * 0.1;
            camera.lookAt(player.mesh.position.x, player.mesh.position.y + 1, player.mesh.position.z);

            // Update UI
            document.getElementById('speed-val').innerText = Math.floor(Math.abs(player.speed));
            
            // Calc Position (Simple: who has higher Z usually implies further, but on a loop its hard. 
            // We will just randomize it for the demo effect or check Distance to next waypoint)
            // (Skipped complex lap logic for brevity)
        }

        // AI Update (Always running)
        if(gameState === 'CINEMATIC' || gameState === 'RACE') {
            aiCars.forEach(ai => ai.update(dt));
        }

        renderer.render(scene, camera);
    }

    init();

</script>
</body>
</html>